This section describes the basic procedure for generating and running tests. 
It covers running a provided test, useful GDB commands, and compiling handwritten tests.

% TODO: Fill out these sections
\subsection{Relevant Files}
\begin{itemize}
\item \textbf{debug\_lockstep/debug.sh} The entry point for the debugging framework. 
\item \textbf{debug\_lockstep/unitTests/*} Randomized tests for every instruction. 
Each test is named with the instruction or instruction type followed by the number of instructions in the test. 
Each test has four or five files
\begin{itemize}
\item \texttt{test.s}, the randomly generated assembly.
\item\texttt{test.dat}, the corresponding hexadecimal machine code.
\item \texttt{test.dump}, the disassembled machine code.
\item \texttt{test.elf}, which contains information about how interrupts are raised in exception handler tests.
\item \texttt{test.bin}, the binary file that runs on the processor and QEMU.
\end{itemize}

\end{itemize}

\subsection{Basic Operation on Provided Tests}
This section demonstrates the most basic operation of the testing framework.
It will allow you to run a test from the terminal and debug in gdb at a register level.
\begin{enumerate}
\item From your local copy of the LEG repository, enter the \texttt{debug\_lockstep} directory.
\item Provided tests are stored in the \texttt{unitTests} directory. 
 To run a provided test, type 
 \begin{verbatim}./debug.sh -t unitTests/testname.bin\end{verbatim}
 at the terminal. For example, to run the test consisting of 1000 random \texttt{ADC} instructions, enter 
 \begin{verbatim}./debug.sh -t unitTests/adc_1000.bin\end{verbatim}
\item LEG will now be compiled by ModelSim and instances of QEMU and GDB will be started.
 If there are no compilation errors, you will be at the prompt of gdb modified with LEG-specific debugging commands.
 Read the list of special commands.
 
 The most basic command is \texttt{leg-lockstep}, which runs LEG until a bug is found.
 Enter this now.
\item The test will print a `\texttt{.}' after each successfully executed instruction.
 If the program completes successfully, a \texttt{PASSED} message will appear.
 Otherwise debugging information will be printed, including the last correct register state, the current incorrect LEG register state, and the expected register state.
\item Debug with any GDB command, or type \texttt{q} to exit GDB.
\end{enumerate}

This guide cannot present a complete tutorial on using GDB, but a few examples of the most useful commands are listed in Table \ref{table:gdb} below.

\begin{table}
\centering
\begin{tabular}{|l|p{10cm}|}
\hline \textbf{command} & \textbf{effect} \\ 
\hline \texttt{stepi} & Execute one instruction \\ 
\hline \texttt{i r} & Print register contents of the current mode, including cpsr \\ 
\hline \texttt{x/10i \$pc} & Print the next 10 instructions \\ 
\hline \texttt{x/10w \$sp-20} & Print 10 words of memory, starting 20 addresses below the stack pointer \\ 
\hline \texttt{x/5b 0xfffdc} & Print 5 bytes of memory, starting at \texttt{0xfffdc} \\ 
\hline \texttt{b *0x220} & Set a breakpoint at address \texttt{0x220} \\ 
\hline 
\end{tabular} 
\caption{Examples of common GDB commands}
\label{table:gdb}
\end{table}

\subsection{Creating Tests}

\subsection{Debugging Tools}

END

% Out of date
\subsection{Creating Tests}
There are two methods for creating tests, either on tera, verified by QEMU, or on the raspberry pi, verified by GDB on the pi. Both methods currently depend on the Pi for assembly and disassembly. 
\subsubsection{Creating Tests on Tera}
Tests can be created on tera in \texttt{/proj/leg/qemu}. 
First create an assembly file of instructions to test. 
This test should have appropriate exception handling setup with branches in the base addresses to each exception handler. 
The results are compared to the integrator board in QEMU. 
The bootloader in QEMU initializes the flags and puts values in r0 and r1. 
To ensure consistent results when comparing ModelSim and QEMU, all tests should start by setting r0, r1, and the condition flags. 
All assembly files should have a \texttt{.s} file extension, for example \texttt{add.s}. To generate the test files, use \texttt{makeQemuTest.sh}. 
For example \texttt{sh makeQemuTest.sh add}

Once the script is started, it will transfer several files to and from the Pi. If you intend to create a lot of tests, you should create a public key for the pi so you don't have to keep typing in the password. Once the files have transferred, QEMU will start. To get the results from QEMU type \texttt{info registers} the \texttt{Ctrl+C} to quit QEMU. This will create the test. 

The results of this process leave you with 6 files. 
\begin{itemize}
\item \texttt{.bin} file: The binary file which can be run on the Pi for debugging. 
\item \texttt{.dat} file: The file that runs on ModelSim. 
\item \texttt{.dump} file: The objdump file that contains useful human readable information about the test.
\item \texttt{.flash} file: The QEMU readable file. 
\item \texttt{.s} file: The assembly source file.
\item \texttt{.val} file: The state of the registers at the end of the program, for comparison against ModelSim. 
\end{itemize}

\subsubsection{Creating Tests on the Pi}
Test creation on the Pi is analagous to tera. 
The username and password for the pi are pi and strawberry, respectively. Creating tests on the Pi does not generate the QEMU compatible file. Generating tests on the pi does not accomodate mode changes and all instructions are executed in user mode. 

